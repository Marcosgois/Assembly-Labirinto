.data
.include "maze.s"
CAMINHO: .space 153600 # Estimativa de pior caso: 4x 320x240/2 tamanho do maior labirinto
BIFURC:	.space 1000

.text
MAIN: 	la a0,maze
	jal draw_maze
	la a1,CAMINHO
	jal solve_maze
#	la a0,CAMINHO
#	jal animate
	li a7,10
	ecall
	
	
# Preenche a tela de vermelho
draw_maze:
	la	s0, maze		# S0 ( Endereço Atual Labirinto )
	li	t0,0xFF009600		# Endereço do meio
	lw 	s1,0(s0)		# Número de Colunas
	addi	s1,s1,1			# Acrescenta 1 nas Colunas
	lw 	s2,4(s0)		# Número de linhas
	addi	s2,s2,1			# Acrescenta 1 nas linhas
	addi 	s0,s0,8			# Primeiro pixel depois das informações de linhas e colunas
 	li	t2, 320			# Resolução Largura
 	li 	t3, 2			# Divisor 2
 	div	t1, s2, t3		# Número de Linhas / 2
 	mul	t1, t1, t2		# Multiplico (Linhas / 2 * 320)
 	neg	t1, t1			# (Número de Linhas / 2)*(320) (Negativo)
 	li	t2, 160
 	add	t0, t0, t1		# Subtraio do Endereço Inicial
 	div	t3, s1,t3		# Número de Colunas / 2
 	sub	t4, t2,t3
 	add	t0, t0, t4		# Endereço Inicial = Meio Deslocamento Direita -> Coluna
 	add	t4, t4, t4		
 	mv	s3, t0			# Endereço Inicial
 	mul	t1, s1, s2		# Quantidade de Pixels no Labirinto
 	li	t2,0			# Zera contador de Linha
 	j	LOOP
 	
new_line:
	li	t2,0
	add	t0, t0, t4
	 	
LOOP:	beqz 	t1, FLOOP		# Se for o último endereço então sai do loop
	lw	t3,0(s0)
	sw 	t3,0(t0)		# escreve a word na memória VGA
	addi 	t1,t1,-4		# soma 4 ao endereço
	addi	s0,s0,4
	addi	t0,t0,4
	addi	t2,t2,4
	bge	t2, s1, new_line
	j 	LOOP			# volta a verificar
FLOOP:	ret
# Carrega a imagem

#Resolve Maze
solve_maze:
	ebreak
	li	t6, 0x07070707		# Cor Vermelha
	li	t2, 320			# Resolução Largura
	li	t1, 2
	div	t1, s1, t1
	add	s3, s3, t1		# Começando pelo Primeiro Pixel
	addi	s3, s3, -1		# Ajusta primeiro pixel
	sb	t6, 0(s3)		# Carrega no s3 o primeiro PIXEL
	mv	t1, s3			# Endereço do s3
	sw	t1, 0(a1)		# Armazena primeiro endereço no "CAMINHO"
	add	t1, t1, t2		# Descendo o Pixel
	j	LOOPsm
LOOPsm:
	sb	t6, 0(t1)		# Carrega no s3 o primeiro PIXEL
	mv	a1, t1
	addi	a1, a1, 4
	addi	s11, s11, 4
	li	s2, zero
	li	s3, zero
	li	s4, zero
	# Confere Pixels Vizinhos
LADOESQ:				# Confere Pixel da Esquerda
	addi	t1, t1, -1
	lb	t3, 0(t1)
	addi	t1, t1, 1
	beqz	t3, EMBAIXO
	addi	t4, t4, 1
	li	s2, 1			# s2 indica vizinho esquerdo
EMBAIXO:
	add	t1, t1, t2		# Confere Pixel de Baixo
	lb	t3, 0(t1)
	neg	t2, t2
	add	t1, t1, t2
	beqz	t3, LADODIR
	addi	t4, t4, 1
	li	s3, 1			# s3 indica vizinho em baixo
LADODIR:				# Confere Pixel da Direita
	addi	t1, t1, 1
	lb	t3, 0(t1)
	addi	t1, t1, -1
	beqz	t3, DECIDELADO
	addi 	t4, t4, 1
	li	s4, 1			# s2 indica vizinho direito
DECIDELADO:
	mv	s5, zero
	bnez	s2, 1			# S2 ESQUERDO
	jal	VERIFICAPILHA
	bnez	s5, 1
	addi	t1, t1, -1
	j	LOOPsm
1:
	mv	s5, zero
	bnez	s3, 2			# S3 EM BAIXO
	jal	VERIFICAPILHA
	bnez	s5, 2
	add	t1, t1, t2
	j	LOOPsm
2:
	mv	s5, zero
	bnez	s4, SEM_SAIDA		# S4 DIREITO
	jal	VERIFICAPILHA
	bnez	s5, TESTAEMB
	addi	t1, t1, 1
	j	LOOPsm
## PAREI AQUI, IMPLEMENTAR CASO SEJA SEM SAÍDA!
	ebreak
	jal	solve_maze	
SEM_SAIDA:
	mv	t1, t3
	addi	a1, a1, -4
	addi	s11, s11, -4
	lw	t1, 0(a1)
	
VERIFICAPILHA:
	mv	s10, zero
LOOPVP:	ble	s10, s11, RETORNA
	mv	s9, a2
	lw	s8, 0(s9)
	lw	s7, 0(t1)
	bne	s8, s7, LOOPVP
	addi	s5, s5, 1
RETORNA:
	ret	

# devolve o controle ao sistema operacional
FIM:	li a7,10		# syscall de exit
	ecall
