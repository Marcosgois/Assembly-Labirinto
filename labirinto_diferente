.data
.include "maze.s"
CAMINHO: .space 153600 # Estimativa de pior caso: 4x 320x240/2 tamanho do maior labirinto

.text
MAIN: 	la a0,maze
	jal draw_maze
	la a1,CAMINHO
	jal solve_maze
#	la a0,CAMINHO
#	jal animate
	li a7,10
	ecall
	
	
# Preenche a tela de vermelho
draw_maze:
	la	s0, maze		# S0 ( Endereço Atual Labirinto )
	li	t0,0xFF009600		# Endereço do meio
	li	t1,0xFFFFFFFF	
	lw 	s1,0(s0)		# Número de Colunas
	addi	s1,s1,1			# Acrescenta 1 nas Colunas
	lw 	s2,4(s0)		# Número de linhas
	addi	s2,s2,1			# Acrescenta 1 nas linhas
	addi 	s0,s0,8			# Primeiro pixel depois das informações de linhas e colunas
 	li	t2, 320
 	li 	t3, 2
 	div	t1, s2, t3		# Número de Linhas / 2
 	mul	t1, t1, t2		# Multiplico por 320
 	neg	t1,t1			# (Número de Colunas / 2)*(320) (Negativo)
 	add	t0, t0, t1		# Subtraio do Endereço Inicial
 	li	t2, 160			# Metade dos Pixels de Largura
 	neg	t4, s1			# Número de Colunas (Negativo)
 	add	t4, t4, t2		# -(Coluna) + Metade dos Pixels
 	add	t5, t2, t2		# t5 = 160 + 160 = 320 Total da Resolução
 	add	t5, t4, t2		# Subtrai o total da resolução pelas Colunas do Labirinto Supracitado
 	add	t0, t0, t4		# Endereço Inicial
 	mv	s3, t0
 	mul	t1, s1, s2		# Quantidade de Pixels no Labirinto
 	li	t2,0			# Zera contador de Linha
 	j	LOOP
 	
new_line:
	li	t2,0
	add	t0, t0, t5
	 	
LOOP:	beqz 	t1, FLOOP		# Se for o último endereço então sai do loop
	lw	t3,0(s0)
	sw 	t3,0(t0)		# escreve a word na memória VGA
	addi 	t1,t1,-4		# soma 4 ao endereço
	addi	s0,s0,4
	addi	t0,t0,4
	addi	t2,t2,4
	bge	t2, s1, new_line
	j 	LOOP			# volta a verificar
FLOOP:	ret
# Carrega a imagem

#Resolve Maze
solve_maze:
	li	s4, 0x07070707		# Cor Vermelha
	lb	s3, 0(s0)		# Carrega no s3 o primeiro PIXEL
	and	s3, s3,s4		# Faz a operação AND com Vermelho e o PIXEL
	sb	s3, 0(t0)		# Colore o Pixel
	addi	s0, s0, -1
	addi	t0, t0, -1
	beqz	s2, SBODY		# Ve se acabou as colunas
	addi	s2, s2, -1
	jal	solve_maze	
	
#Resolve Maze (Corpo)

SBODY:	li	s8, 2
	mul	s8, s8, s1
	sub	t2, t2, s8		# Contador Precisa diminuir 2 vezes as linhas pois nao é percorrido
LOOPSB:	addi	t2, t2, -1
	beqz	t2, FIM
	addi	s0, s0, -1
	addi	t0, t0, -1
	lb 	t3, 0(t0)		# Início do labirinto
	bnez	t3, ARG
	jal	LOOPSB
	
ARG:	li	t6,0			# Esquerda
	li	s6,0
	li	s5, 0xFFFFFFFF
	lb	t3, -1(t0)
	beqz	t3, ARG2
	addi	t6,t6,1
ARG2:	lb	t3, -8(t0)		#Em cima
	beqz	t3, ARG3
	addi	t6,t6,1
ARG3:	lb	t3, 8(t0)		#Em baixo
	beqz	t3, ARG4
	sub	t3,t3,s5
	beqz	t3, ARG4
	addi 	t6,t6,1	
ARG4:	lb	t3, 1(t0)		#Direita
	beqz	t3, COMP
	sub	t3,t3,s5
	beqz	t3, COMP
	addi	t6,t6,1
COMP:	li	t5, 2
	bge	t6,t5,RED	
	j	LOOPSB

RED:	li	s7,0x07070707		# Variável Vermelha (Pixel 1)
	sb	s7, 0(t0)
	jal LOOPSB
	
# devolve o controle ao sistema operacional
FIM:	li a7,10		# syscall de exit
	ecall